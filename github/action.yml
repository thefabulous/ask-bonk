name: "Bonk GitHub Action"
description: "Run Bonk (OpenCode) in GitHub Actions workflows"
branding:
  icon: "git-pull-request"
  color: "orange"

inputs:
  model:
    description: "Model to use (e.g., opencode/claude-opus-4-5)"
    required: true

  agent:
    description: "Set the agent to use for this workflow. Falls back to the default_agent if set in config, else 'build'"
    required: false

  prompt:
    description: "Custom prompt to override the default prompt"
    required: false

  mentions:
    description: "Comma-separated trigger phrases (e.g., '/bonk,@ask-bonk')"
    required: false
    default: "/bonk,@ask-bonk"

  permissions:
    description: "Required permission level: 'admin', 'write', 'any', or 'CODEOWNERS' (checks .github/CODEOWNERS)"
    required: false
    default: "write"

  oidc_base_url:
    description: "Base URL for OIDC token exchange"
    required: false
    default: "https://ask-bonk.silverlock.workers.dev/auth"

  forks:
    description: "Post a 'not supported' comment on fork PRs. Set to 'false' to silently skip fork PRs."
    required: false
    default: "true"

  opencode_dev:
    description: "Install OpenCode from dev branch instead of latest release"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Check mentions
      id: mentions
      shell: bash
      env:
        EVENT_NAME: ${{ github.event_name }}
        COMMENT_BODY: ${{ github.event.comment.body }}
        REVIEW_BODY: ${{ github.event.review.body }}
        MENTIONS: ${{ inputs.mentions }}
      run: |
        BODY=""

        case "$EVENT_NAME" in
          issue_comment|pull_request_review_comment)
            BODY="$COMMENT_BODY"
            ;;
          pull_request_review)
            BODY="$REVIEW_BODY"
            ;;
          issues|pull_request|workflow_dispatch|schedule)
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
            ;;
          *)
            echo "Unsupported event type: $EVENT_NAME"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
            ;;
        esac

        IFS=',' read -ra MENTION_ARRAY <<< "$MENTIONS"

        for mention in "${MENTION_ARRAY[@]}"; do
          mention="${mention#"${mention%%[![:space:]]*}"}"
          mention="${mention%"${mention##*[![:space:]]}"}"
          if [[ "$BODY" == *"$mention"* ]]; then
            echo "Found mention: $mention"
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi
        done

        echo "No matching mention found in comment"
        echo "skip=true" >> $GITHUB_OUTPUT

    - name: Check user permission
      if: inputs.permissions != 'any' && steps.mentions.outputs.skip != 'true'
      uses: actions/github-script@v7
      env:
        REQUIRED_PERMISSION: ${{ inputs.permissions }}
      with:
        script: |
          // Retry transient GitHub API errors (5xx) with exponential backoff
          async function withRetry(fn, label, retries = 3, baseDelay = 2000) {
            for (let attempt = 0; attempt <= retries; attempt++) {
              try {
                return await fn();
              } catch (e) {
                const isTransient = e.status >= 500;
                if (attempt === retries || !isTransient) throw e;
                const delay = baseDelay * Math.pow(2, attempt);
                core.warning(`${label}: ${e.status} ${e.message} â€” retrying in ${delay}ms (attempt ${attempt + 1}/${retries})`);
                await new Promise(r => setTimeout(r, delay));
              }
            }
          }

          const requiredPermission = process.env.REQUIRED_PERMISSION;
          const actor = context.actor;

          const { data: permissionLevel } = await withRetry(
            () => github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: actor
            }),
            'Permission check'
          );
          const permission = permissionLevel.permission;

          if (requiredPermission === 'CODEOWNERS') {
            let codeownersContent = '';
            const paths = ['.github/CODEOWNERS', 'CODEOWNERS', 'docs/CODEOWNERS'];

            for (const path of paths) {
              try {
                const { data } = await withRetry(
                  () => github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: path,
                    ref: context.ref || 'HEAD'
                  }),
                  `CODEOWNERS fetch (${path})`
                );
                codeownersContent = Buffer.from(data.content, 'base64').toString('utf8');
                core.info(`Found CODEOWNERS at ${path}`);
                break;
              } catch (e) {
                if (e.status !== 404) throw e;
              }
            }

            if (!codeownersContent) {
              core.setFailed('CODEOWNERS file not found in .github/, root, or docs/ directory');
              return;
            }

            // Parse CODEOWNERS: collect individual users and team patterns (@org/team)
            const owners = new Set();
            const teamPatterns = [];
            for (const line of codeownersContent.split('\n')) {
              const trimmed = line.trim();
              if (!trimmed || trimmed.startsWith('#')) continue;
              const mentions = trimmed.match(/@[\w-]+(?:\/[\w-]+)?/g) || [];
              for (const mention of mentions) {
                if (mention.includes('/')) {
                  // Cross-org teams (@other-org/team) are allowed if repo admin put them in CODEOWNERS
                  teamPatterns.push(mention.substring(1));
                } else {
                  // GitHub usernames are case-insensitive
                  owners.add(mention.substring(1).toLowerCase());
                }
              }
            }

            const actorLower = actor.toLowerCase();

            if (owners.has(actorLower)) {
              core.info(`User ${actor} is a code owner`);
              return;
            }

            // Check team membership. Stale/non-existent teams 404 and are skipped.
            // GitHub API normalizes team_slug case, so no lowercase needed.
            for (const teamPath of teamPatterns) {
              const [org, team] = teamPath.split('/');
              try {
                await withRetry(
                  () => github.rest.teams.getMembershipForUserInOrg({
                    org: org,
                    team_slug: team,
                    username: actor
                  }),
                  `Team membership check (@${teamPath})`
                );
                core.info(`User ${actor} is a member of team @${teamPath}`);
                return;
              } catch (e) {
                // 404 = not a member or team doesn't exist; continue checking other patterns
                if (e.status !== 404) {
                  core.warning(`Could not check team membership for @${teamPath}: ${e.message}`);
                }
              }
            }

            // Fail-closed: no matching user or team membership found
            core.setFailed(`User ${actor} is not listed in CODEOWNERS`);
          } else if (requiredPermission === 'admin') {
            if (permission !== 'admin') {
              core.setFailed(`User ${actor} does not have admin permission (has: ${permission})`);
            }
          } else if (requiredPermission === 'write') {
            if (permission !== 'admin' && permission !== 'write') {
              core.setFailed(`User ${actor} does not have write permission (has: ${permission})`);
            }
          } else {
            core.setFailed(`Unknown permission level: ${requiredPermission}. Use 'admin', 'write', 'any', or 'CODEOWNERS'`);
          }

    - name: Setup bun
      if: success() && steps.mentions.outputs.skip != 'true'
      uses: oven-sh/setup-bun@v2

    - name: Ensure workflow exists
      if: success() && steps.mentions.outputs.skip != 'true'
      id: setup
      shell: bash
      env:
        OIDC_BASE_URL: ${{ inputs.oidc_base_url }}
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        GITHUB_REPOSITORY_NAME: ${{ github.event.repository.name }}
        ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        EVENT_NAME: ${{ github.event_name }}
      run: bun run ${{ github.action_path }}/script/setup.ts

    - name: Get opencode version
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true'
      id: version
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        OPENCODE_DEV: ${{ inputs.opencode_dev }}
      run: bun run ${{ github.action_path }}/script/version.ts

    - name: Cache opencode
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true' && steps.version.outputs.cacheable == 'true'
      id: cache
      uses: actions/cache@v4
      with:
        path: ~/.opencode/bin
        key: opencode-${{ runner.os }}-${{ runner.arch }}-${{ steps.version.outputs.version }}

    - name: Install opencode
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true' && steps.cache.outputs.cache-hit != 'true'
      shell: bash
      env:
        OPENCODE_DEV: ${{ steps.version.outputs.dev }}
      run: |
        set -euo pipefail
        if [ "$OPENCODE_DEV" = "true" ]; then
          curl -fsSL --connect-timeout 5 --max-time 60 https://opencode.ai/install -o /tmp/opencode-install.sh
          bash /tmp/opencode-install.sh --dev
        else
          curl -fsSL --connect-timeout 5 --max-time 60 https://opencode.ai/install -o /tmp/opencode-install.sh
          bash /tmp/opencode-install.sh
        fi

    - name: Add opencode to PATH
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true'
      shell: bash
      run: echo "$HOME/.opencode/bin" >> $GITHUB_PATH

    - name: Configure Git
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true'
      shell: bash
      run: |
        git config --global user.name "ask-bonk[bot]"
        git config --global user.email "ask-bonk[bot]@users.noreply.github.com"

    - name: Build prompt
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true'
      id: prompt
      shell: bash
      env:
        EVENT_NAME: ${{ github.event_name }}
        PR_HEAD_REPO: ${{ github.event.pull_request.head.repo.full_name }}
        PR_BASE_REPO: ${{ github.event.pull_request.base.repo.full_name }}
        REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.issue.pull_request.url && github.event.issue.number || github.event.pull_request.number || '' }}
        GH_TOKEN: ${{ github.token }}
        PR_URL: ${{ github.event.pull_request.url || github.event.issue.pull_request.url || '' }}
        USER_PROMPT: ${{ inputs.prompt }}
        ACTION_PATH: ${{ github.action_path }}
        ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
      run: bun run ${{ github.action_path }}/script/prompt.ts

    - name: Exchange OIDC token for GitHub App token
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true'
      id: oidc
      shell: bash
      env:
        OIDC_BASE_URL: ${{ inputs.oidc_base_url }}
        FALLBACK_TOKEN: ${{ github.token }}
      run: bun run ${{ github.action_path }}/script/oidc-exchange.ts

    - name: Handle fork PR
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true' && steps.prompt.outputs.is_fork == 'true'
      id: fork
      shell: bash
      env:
        OIDC_FAILED: ${{ steps.oidc.outputs.oidc_failed }}
        REPOSITORY: ${{ github.repository }}
        ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        ACTOR: ${{ github.event.comment.user.login || github.event.review.user.login || github.actor }}
        FORKS: ${{ inputs.forks }}
      run: bun run ${{ github.action_path }}/script/fork-comment.ts

    - name: Require OIDC for non-fork runs
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true' && steps.prompt.outputs.is_fork != 'true'
      shell: bash
      run: |
        if [ "${OIDC_FAILED}" = "true" ]; then
          echo "::error::OIDC token exchange failed. Ensure id-token: write is configured."
          exit 1
        fi
      env:
        OIDC_FAILED: ${{ steps.oidc.outputs.oidc_failed }}

    - name: Track Bonk run
      if: success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true' && steps.prompt.outputs.is_fork != 'true' && steps.oidc.outputs.oidc_failed != 'true'
      shell: bash
      env:
        OIDC_BASE_URL: ${{ inputs.oidc_base_url }}
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        GITHUB_REPOSITORY_NAME: ${{ github.event.repository.name }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_SERVER_URL: ${{ github.server_url }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        EVENT_NAME: ${{ github.event_name }}
        ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        COMMENT_ID: ${{ github.event.comment.id }}
        COMMENT_CREATED_AT: ${{ github.event.comment.created_at }}
        ISSUE_CREATED_AT: ${{ github.event.issue.created_at || github.event.pull_request.created_at }}
      run: bun run ${{ github.action_path }}/script/track.ts

    - name: Run opencode
      if: |
        success() && steps.mentions.outputs.skip != 'true' && steps.setup.outputs.skip != 'true'
        && (steps.prompt.outputs.is_fork != 'true' || steps.fork.outputs.run_opencode == 'true')
      id: opencode
      shell: bash
      run: |
        set +e
        # GH_TOKEN is the App token written to GITHUB_ENV by the OIDC exchange step.
        export USE_GITHUB_TOKEN=true
        export GITHUB_TOKEN="${GH_TOKEN}"
        timeout 45m opencode github run
        EXIT_CODE=$?
        echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
        exit $EXIT_CODE
      env:
        MODEL: ${{ inputs.model }}
        AGENT: ${{ inputs.agent }}
        PROMPT: ${{ steps.prompt.outputs.value }}
        SHARE: false
        MENTIONS: ${{ inputs.mentions }}
        OIDC_BASE_URL: ${{ inputs.oidc_base_url }}

    - name: Finalize Bonk run
      if: |
        always() && steps.setup.outcome == 'success' && steps.mentions.outputs.skip != 'true'
        && steps.setup.outputs.skip != 'true' && steps.prompt.outcome == 'success'
        && (steps.prompt.outputs.is_fork != 'true' || steps.fork.outputs.run_opencode == 'true')
      shell: bash
      env:
        OIDC_BASE_URL: ${{ inputs.oidc_base_url }}
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        GITHUB_REPOSITORY_NAME: ${{ github.event.repository.name }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_SERVER_URL: ${{ github.server_url }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        OPENCODE_STATUS: ${{ steps.opencode.outcome }}
      run: bun run ${{ github.action_path }}/script/finalize.ts
